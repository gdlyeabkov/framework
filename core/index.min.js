/*
    hooks
*/
    const mountedHook = () => {
    
    }

    const destroyHook = () => {
        
    }

    /*
        classes
    */

    class Fast {
        
        box = {}
        components = []
        isComponentsLoad = false
        hooks = {}
        streams = {}

        constructor (options) {
            console.log(`создаю Fast с настройками: ${options}`)
            let optionsKeys = Object.keys(options)
            let optionsValues = Object.values(options)
            optionsKeys.map((option, optionIndex) => {
                console.log(`Настройка: ${option}`)
                if (option === 'box') {
                    let customBox = optionsValues[optionIndex]
                    if (typeof customBox === 'object') {
                        console.log(`Коробка - это объект значит все впорядке`)
                        this.box = customBox
                    } else {
                        console.log(`Коробка должна быть объектом с данными: ${typeof optionsValues[optionIndex]}`)
                    }
                } else if (option === 'mounted') {
                    let mountedValue = optionsValues[optionIndex]
                    if (typeof mountedValue === 'function') {
                        console.log(`Mounted - это функция значит все впорядке`)
                        this.mountedHook = mountedValue
                    } else {
                        console.log(`Mounted должна быть функцией выполняющейся при старте: ${typeof optionsValues[optionIndex]}`)
                    }
                } else if (option === 'updated') {
                    let updatedValue = optionsValues[optionIndex]
                    if (typeof updatedValue === 'function') {
                        console.log(`Updated - это функция значит все впорядке`)
                        this.updatedHook = updatedValue
                    } else {
                        console.log(`Updated должна быть функцией выполняющейся после каждого изменения данных: ${typeof optionsValues[optionIndex]}`)
                    }
                } else if (option === 'methods') {
                    let methodsValue = optionsValues[optionIndex]
                    if (typeof methodsValue === 'object') {
                        console.log(`Methods - это объект из функций значит все впорядке`)
                        this.hooks = methodsValue
                        Object.keys(this.hooks).map(hook => {
                            this[hook] = this.hooks[hook]
                        })
                    } else {
                        console.log(`Methods должна быть объектом из функциий: ${typeof optionsValues[optionIndex]}`)
                    }
                } else if (option === 'filters') {
                    let filtersValue = optionsValues[optionIndex]
                    if (typeof filtersValue === 'object') {
                        console.log(`Filters - это объект из функций значит все впорядке`)
                        this.streams = filtersValue
                        Object.keys(this.streams).map(stream => {
                            this[stream] = this.streams[stream]
                        })
                    } else {
                        console.log(`Filters должна быть объектом из функциий: ${typeof optionsValues[optionIndex]}`)
                    }
                } else if (option === 'components') {
                    let customComponents = optionsValues[optionIndex]
                    this.components = customComponents
                    if (typeof customComponents === 'object' && customComponents[0] !== undefined) {
                        console.log(`Компоненты - это массив значит все впорядке`)
                    } else {
                        console.log(`Компоненты должны быть массивом с данными: ${typeof optionsValues[optionIndex]}`)
                    }
                }
            })
            this.mountedHook()
            setInterval(() => this.detectCustomElements(), 1000)
        }

        openBox() {
            return this.box
        }

        detectCustomElements() {
            this.updatedHook()
            let customElements = Object.values(document.body.children)
            customElements.map(element => {
                let isElementWantOpenBox = element.getAttribute('fast-text') || (element.textContent.startsWith('{{') && element.textContent.endsWith('}}'))
                let isElementWantToggleBox = element.getAttribute('fast-model')
                let elementAttributes = Object.values(element.attributes).map(attribute => attribute.name)
                // alert(`elementAttributes: ${elementAttributes}`)
                let isElementWantEvent = element.getAttribute('@click')
                if (isElementWantOpenBox) {
                    let supportedElements = [
                        'SPAN',
                        'P',
                        'H1',
                        'H2',
                        'H3',
                        'H4',
                        'H5',
                        'H6',
                    ]
                    if (supportedElements.includes(element.tagName)) {
                        if (element.textContent.startsWith('{{')) {
                            let boxItemKey = element.textContent.replaceAll('{{', '').replaceAll('}}', '').replaceAll(' ', '').replaceAll('\n', '')
                            let filterItems = boxItemKey.split('|')
                            let isFiltersApply = filterItems.length >= 2
                            if (isFiltersApply) {
                                element.textContent = this[filterItems[1]](filterItems[0])
                            } else {
                                element.textContent = this.box[boxItemKey]
                            }
                        } else {
                            element.textContent = this.box[isElementWantOpenBox]
                        }
                    }
                } else if (isElementWantToggleBox) {
                    let supportedElements = [
                        'INPUT',
                        'TEXTAREA',
                    ]
                    if (supportedElements.includes(element.tagName)) {
                        element.value = this.box[isElementWantToggleBox]
                        element.addEventListener('input', (event) => {
                            this.box[isElementWantToggleBox] = event.target.value
                        })
                    }
                } else if (!this.isComponentsLoad) {
                    let allChildrens = Object.values(document.body.children)
                    let registerdComponentsNames = this.components.map(element => element.name.toUpperCase())
                    allChildrens.map((component, componentIdx) => {
                        if (registerdComponentsNames.includes(component.tagName)) {
                            let nestedContent = component.innerHTML
                            component.innerHTML = ''
                            let customComponent = document.createElement(component.tagName)
                            let componentTemplate = this.components.filter(otherComponent => otherComponent.name.toUpperCase() === component.tagName)[0].template
                            customComponent.innerHTML = componentTemplate.replaceAll('<fast-nest />', nestedContent)
                            document.body.insertBefore(customComponent, allChildrens[componentIdx + 1])
                        }
                    })
                    this.isComponentsLoad = true
                } else if (elementAttributes.join('').includes('@')) {
                    Object.values(element.attributes).filter(elementAttribute => elementAttribute.name.includes('@')).map(elementAttribute => {
                        let eventType = elementAttribute.name.split('@')[1]
                        if (!element.hasAttribute(`data-fast-${eventType}-hander`)) {
                            alert(elementAttribute.name.split('@')[1])
                            element.setAttribute(`data-fast-${eventType}-hander`, true)
                            element.addEventListener(eventType, () => this[elementAttribute.value]())
                        }
                    })
                }
            })
        }

        mountedHook() {

        }

        updatedHook() {

        }

    }

    window.onload = () => mountedHook()
    window.onclose = () => destroyHook()